## 集合

![image-20220706102507538](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220706102507538.png)

### HashMap怎么遍历

ForEach循环进行遍历(entryset)、ForEach迭代键值集合进行遍历(keyset、values）、lambda表达式



### String、StringBuffer、StringBuilder

- String 不可变，因为其字符串数组加了final关键字，后二者可变
- 前二者线程安全，StringBuilder线程不安全
- 操作少量数据用String，单线程大量数据用StringBuilder（性能比StringBuffer高10%-15%），多线程大量数据用StringBuffer

### 为什么重写equals()时必须重写hashcode()?

hashcode()的作用就是获取哈希码，它实际上是返回一个int整数，哈希码作用是确定该对象在哈希表中的索引位置。所以hashCode()实际上必须要完成的一件事情就是，**为该equals()认定为相同的对象返回相同的哈希值**。

那么为什么一定要确保上述原则呢？

举个例子，hashmap的put函数源码中就对要放置的对象的key的hashcode进行了对比以区分是否是同一对象，如果我们put两个字面量相同的s1和s2希望用s2对应的值去覆盖s1，会发现如若没有重写hashcode方法，由于二者的地址不同会被判定为不同对象。结果自然不尽如人意。

## Spring

#### 说说你对IOC的理解

![image-20220706105648966](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220706105648966.png)

#### 



## jvm

大纲

![image-20220621164036667](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220621164036667.png)

![image-20220621163701226](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220621163701226.png)

使用jdk\bin\visualvm.exe进行可视化堆栈的使用情况，同时使用dump进行分析。

### 导致栈内存溢出的原因？

- 栈帧过多导致栈内存溢出（结束条件设置错误的递归调用）
- 类属性嵌套的时候进行json转换时，导致无限循环，解决方案（@JsonIgnored）

### 线程运行诊断

定位：top + ps H -eo pid,tid,%cpu |grep 进程id

jstack 进程id 可以根据线程id定位到出问题的代码行数

### 直接内存的释放

虚引用Cleanner对象的clean方法中进行处理，通过unsafe.freeMemory()进行主动释放。

### 垃圾回收

####  如何判断对象可以回收？

可达性分析算法

如果一个对象可以被根对象（GC root）直接或间接地引用，那么就不能被回收。

#### 哪些对象能够成为GC root对象？

```shell
jmap -dump:format = b,live # 得到快照文件后使用mat工具进行查看
```

#### 引用队列

软引用、弱引用、虚引用、终结器引用等存放的队列，方便进行垃圾回收

#### 软引用的使用

- 针对不重要的资源

- Full GC后堆内存仍不够时触发释放内存，弱引用是在垃圾回收时会主动进行释放

- 配合引用队列进行软引用对象的清理

```java
ReferenceQueue<byte[]> queue = new ReferenceQueue<>();
List<SoftReference<byte[]>> list = new ArrayList<>();
// 关联了引用队列，当软引用所关联的byte[]被回收时，软引用自己会加入到queue中去，方便用list.remove()回收，弱引用同理
SoftReference<byte[]> ref = new SoftReference<>(new byte[_4MB],queue);
// 如果内存不够，会触发软引用的释放内存操作
list.add(ref);
```

### 垃圾回收算法

#### 标记清除算法

优点：速度快，缺点：容易造成内存碎片，导致内存溢出

#### 标记整理算法

整理内存碎片为一个连续区间，缺点：涉及对象的移动，效率低同时牵涉到对象的引用等问题。

#### 复制算法

不会有内存碎片，需要占用双倍内存空间。

#### 分代垃圾回收机制

![image-20220622200617643](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220622200617643.png)

针对老年代（长期存活的对象）和新生代（回收频发的对象）采取不同的垃圾回收算法

- 对象首先分配在伊甸园区域
- 新生代空间不足时，触发minor gc，伊甸园和from存活的对象使用copy复制到to中，存活的对象年龄加1并且交换from to
- minor gc会引发stop the world（STW），暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行
- 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）
- 当老年代空间不足，会先尝试触发minor gc，如果之后空间仍不足，那么触发full gc，STW的时间更长

### 相关VM参数

| 含义               | 参数                                                         |
| ------------------ | ------------------------------------------------------------ |
| 堆初始大小         | -Xms                                                         |
| 堆最大大小         | -Xmx 或 -XX:MaxHeapSize=size                                 |
| 新生代大小         | -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size)             |
| 幸存区比例（动态） | -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy |
| 伊甸园和幸存区比例 | -XX:SurvivorRatio=ratio                                      |
| 配置晋升阈值       | -XX:+MaxTenuringThreshold=threshold                          |
| 打印晋升详情       | -XX:+PrintTenuringDistribution                               |
| GC详情             | -XX:+PrintGCDetails -verbose:gc                              |
| FullGC前MinorGC    | -XX:+ScavengeBeforeFullGC                                    |
| 新生代和老年代比例 | -XX:NewRatio=2                                               |

### 垃圾回收器

#### G1



##### 新生代调优

- -Xmn 新生代的空间占到整个堆内存的25%-50%即可，确保（所有请求响应*并发量）能够被容纳。

- 幸存区大到能够保留【当前保留对象和需要晋升对象】。
- 晋升阈值配置得当，让长时间存活对象尽快晋升。

##### 老年代调优

以CMS为例

- 老年代空间越大越好
- 先不要调优，尝试新生代调优



### 字节码分析

#### 方法调用

- 私有方法、静态方法 -- invokestatic静态绑定

- public方法 -- invokevirtual动态绑定

- HSDB工具进行查看

![image-20220625150810409](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220625150810409.png)

#### 异常处理

- 通过exception table进行处理，存储监测的行数 **[from,to)** 、异常类型、跳转行数。

![image-20220625151539893](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220625151539893.png)

- finally块的代码会分别复制到try和catch之后

- 同时在exception table中添加两行检测try和catch以防出现监测异常以外的异常，并在最后将该异常抛出。


  ![image-20220625152456415](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220625152456415.png)

![image-20220625152553976](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220625152553976.png)

- 如果在finally中加了return语句会吞掉异常。

  ![image-20220625153126203](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220625153126203.png)

上面的结果返回10

### 类加载过程

#### 加载

![image-20220625161317516](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220625161317516.png)

#### 链接

- **验证**类是否Java字节码是否符合JVM规范
- **准备**![image-20220625161953998](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220625161953998.png)

- **解析**：将类中的符号引用解析为直接引用。

#### 初始化

##### 发生时机

![image-20220625162428972](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220625162428972.png)

### 类加载器

#### 分类

![image-20220625163921734](%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95/image-20220625163921734.png)

#### 双亲委派机制



### synchronized优化

- volatile可保证可见性

- volatile禁用指令重排
