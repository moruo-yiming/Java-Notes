# 堆专题（上）

## 一、堆系列问题的特点

> 注：本文章系本人阅读[博主lucifer的leetcode题解](https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/)做的总结，涉及到的题目均来自[leetcode官网](https://leetcode-cn.com/)，侵删。

### 1.1 **中心**：动态求极值

堆一般用于求极值问题，但如果不是动态的就没必要使用堆，会增加时间成本。

所谓动态，简单来说就是堆内数据在动态变化，也就是堆的大小在变化，下面举例说明。

> **例一、1046.[最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)**
>
> **题目描述：**
>
> 有一堆石头，每块石头的重量都是正整数。
>
> 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
>
> 如果 x == y，那么两块石头都会被完全粉碎；
> 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
> 最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。
>
> **思路：**
>
> 每次选择最重的两块石头进行粉碎之后，最重的石头的重量便发生了改变，将会影响到下次取最重的石头，简单来说就是最重的石头在模拟过程中是**动态变化**的。
>
> **代码：**
>
> ```java
> public int lastStoneWeight(int[] stones) {
>      int n = stones.length;
>      PriorityQueue<Integer> maxHeap = new PriorityQueue<>(n, (a, b) -> b - a);
>      for (int stone : stones) {
>          maxHeap.add(stone);
>      }   
>      while (maxHeap.size() >= 2) {
>          Integer head1 = maxHeap.poll();
>          Integer head2 = maxHeap.poll();
>          if (head1==head2) {
>              continue;
>          }
>          maxHeap.offer(head1 - head2);
>      }
>      if (maxHeap.isEmpty()) {
>          return 0;
>      }
>      return maxHeap.poll();
>  }
> ```
>
> **例二、313. [超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)**
>
> **题目描述：**
>
> 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。
>
> 给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。
>
> 题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。
>
> **思路：**
>
> 对于丑数的定义，有以下结论：
>
> - 1是最小的丑数
> - 对于任意一个丑数x，其与任意给定的质因数primes[i]相乘，结果仍为丑数。
>
> 解题步骤：
>
> 1. 起始先将最小丑数 1 放入队列
> 2. 每次从队列取出最小值 x，然后将 x 所对应的丑数 x * primes[i]进行入队。
> 3. 对步骤 2 循环多次，第 n 次出队的值即是答案。
>
> **代码：**
>
> ```java
> public int nthSuperUglyNumber(int n, int[] primes){
>         PriorityQueue<Integer> queue=new PriorityQueue<>();
>         queue.add(1);
>         while(n-- > 0) {
>             int x = queue.poll();
>             if (n == 0) return x;
>             for(int k : primes) {
>                 if (k <= Integer.MAX_VALUE / x) queue.add(k * x);
>                 if (x % k == 0) break;
>             }
>         }
>         return -1;
>     }
> ```
>

### 1.2 **实现**：二叉堆

以小顶堆为例，实现堆的功能，关键是始终维持堆的性质不变，也就是父节点的权值不大于子节点的权值。

为了达到这个目的，我们需要在出堆和入堆的时候，使用上浮和下沉操作，并恰当地完成元素交换。具体来说就是上浮过程和比它大的父节点进行交换，下沉过程和两个子节点中较小的进行交换，当然前提是它有两个子节点且子结点比它小。

> **关键代码：**
>
> ```java
> /**
>  * 前置条件：起点为1
>  * 核心方法:
>  * shiftDown: 交换下沉
>  * shiftUp: 交换上浮
>  * build: 构建堆
>  **/
> 
> public void shiftDown(int i) {
>         int temp = queue[i];
>         while ((i << 1) <= size) {
>             int child = i << 1;
>             if (child != size && queue[child+1] < queue[child]) {
>                 child++;
>             }
>             if (temp > queue[child]) {
>                 queue[i] = queue[child];
>                 i = child;
>             } else {
>                 break;
>             }
>         }
>         queue[i] = temp;
>     }
> 
> public void shiftUp(int i) {
>         int temp = queue[i];
>         while ((i >> 1)>0) {
>             if (temp < queue[i >> 1]) {
>                 queue[i] = queue[i >> 1];
>                 i >>= 1;
>             } else {
>                 break;
>             }
>         }
>         queue[i] = temp;
>     }
> 
> public void buildHeap() {
>         for (int i = size >> 1; i > 0; i--) {
>             shiftDown(i);
>         }
>     }
> ```

### 1.3 解题技巧

#### 技巧一：固定堆

这个技巧指的是固定堆的大小k不变，代码上可以通过每pop出去一个就push进来一个来实现。

> **例一：** [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
>
> **思路**：建立小顶堆，并维持堆的大小为k。处理完最后一个元素，堆顶的数就是所求。
>
> **代码**：
>
> ```java
> public int findKthLargest(int[] nums, int k) {
>      PriorityQueue<Integer> pq = new PriorityQueue<>();
>      for (int num : nums){
>          pq.offer(num);
>          if (pq.size() > k){
>              pq.poll();
>          }
>      }
>      return pq.poll();
>  }
> ```
>
> **例二：**[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)
>
> **思路：**
>
> 建立一个**小顶堆**，然后遍历「出现次数数组」
>
> 如果堆的元素个数小于 k，就可以直接插入堆中。
> 如果堆的元素个数等于 k，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 k 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。（[题解来源](https://leetcode-cn.com/problems/top-k-frequent-elements/solution/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/)）
>
> **代码：**
>
> ```java
> public int[] topKFrequent(int[] nums, int k) {
>         Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();
>         for (int num : nums) {
>             occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);
>         }
>         PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {
>             @Override
>             public int compare(int[] o1, int[] o2) {
>                 return o1[1] - o2[1];
>             }
>         });
>         for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {
>             Integer num = entry.getKey();
>             Integer count = entry.getValue();
>             if (queue.size() == k) {
>                 if (queue.peek()[1] < count) {
>                     queue.poll();
>                     queue.offer(new int[]{num, count});
>                 }
>             } else {
>                 queue.offer(new int[]{num, count});
>             }
>         }
>         int[] ret = new int[k];
>         for (int i = 0; i < k; i++) {
>             ret[i] = queue.poll()[0];
>         }
>         return ret;
>     }
> ```
>
> **其他相关题目：**[295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)、[857. 雇佣 K 名工人的最低成本](https://leetcode-cn.com/problems/minimum-cost-to-hire-k-workers/)

#### 技巧二：多路归并

这个技巧可以运用在前面的超级丑数问题上。（[题解](https://leetcode-cn.com/problems/super-ugly-number/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-jyow/)）

多路体现在：有多条候选路线。代码上，我们可使用多指针来表示。
归并体现在：结果可能是多个候选路线中最长的或者最短，也可能是第 k 个 等。因此我们需要对多条路线的结果进行比较，并根据题目描述舍弃或者选取某一个或多个路线。	

> **例子：**[1439. 有序矩阵中的第 k 个最小数组和](https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/)
>
> **思路：**这道题就是给你 m 个长度均相同的一维数组，让我们从这 m 个数组中分别选出一个数，即一共选取 m 个数，求这 m 个数的和是所有选取可能性中和第 k 小的。
>
> 而最小的我们是容易知道的，即所有的一维数组首项和。我们又发现，根据最小的，我们可以推导出第 2 小，推导的方式就是移动其中一个指针，这就一共分裂出了 n 种情况了，其中 n 为一维数组长度，第 2 小的就在这分裂中的 n 种情况中，而筛选的方式是这 n 种情况和最小的，后面的情况也是类似。不难看出每次分裂之后极值也发生了变化，因此这是一个明显的求动态求极值的信号，使用堆是一个不错的选择。
>
> 不得不说，难度为hard的题果真不是我这个阶段能轻易overcome的。这里依旧上[题解](https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/solution/java-qing-xi-liang-chong-jie-fa-1bao-li-vtu4n/)：
>
> ​		一个类似于层次遍历的思路，每次利用最小堆 弹出上次的最小值以及坐标，然后依次将坐标往后挪动1位，再放入最小堆。
>
> **代码：**
>
> ```java
> class Solution {
>     class Info implements Comparable<Info>{
> 		int currentSum;
> 		List<Integer> pointers;
> 		Info(int currentSum,List<Integer> pointers){
> 			this.currentSum = currentSum;
> 			this.pointers = pointers;
> 		}
> 		@Override
> 		public String toString() {
> 			return this.currentSum+","+this.pointers;
> 		}
> 		@Override
> 		public int compareTo(Info other) {//从小到大排序
> 			return this.currentSum-other.currentSum;
> 		}
> 		
> 	}
>   public int kthSmallest(int[][] mat, int k) {
>     	
>     	int m = mat.length,n=mat[0].length;
>     	PriorityQueue<Info> queue= new PriorityQueue<Info>();
>     	Set<List<Integer>> seen = new HashSet<>();
>     	int currentSum = 0;
>     	List<Integer> pointers = new ArrayList<>();// 用int[]， contains识别不出来
>     	for(int i=0;i<m;++i) {
>     		currentSum+=mat[i][0];
>     		pointers.add(0);
>     		
>     	}
>     	queue.offer(new Info(currentSum,pointers));
>     	seen.add(pointers);
>     	for(int i=0;i<k;++i) {
>     		Info info = queue.poll();
>     		currentSum = info.currentSum;
>     		pointers = info.pointers;
>     		//每个指针轮流向后移动1个
>     		for(int row=0;row<m;++row) {
>     			List<Integer> newpointers = new ArrayList<>(pointers);
>     			int newsum = currentSum;
>     			int col = pointers.get(row);
>     			if(col<n-1) {
>     				newpointers.set(row, col+1);
>     				if(!seen.contains(newpointers)) {
>     					newsum  += -mat[row][col]+mat[row][col+1];
>     					queue.offer(new Info(newsum,newpointers));
>     					seen.add(newpointers);
>     				}
>     			}
>     		}
>     		
>     	}
>     	
>     	return currentSum;
>     	
>     }
> }
> 
> 作者：SamanthaChen
> 链接：https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/solution/java-qing-xi-liang-chong-jie-fa-1bao-li-vtu4n/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
> ```
>
> **其他相关题目：**（均为hard)[719. 找出第 k 小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)、[632. 最小区间](https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/)、[1675. 数组的最小偏移量](https://leetcode-cn.com/problems/minimize-deviation-in-array/)

#### 技巧三：事后小诸葛

思路： 

例题：[1642. 可以到达的最远建筑](https://leetcode-cn.com/problems/furthest-building-you-can-reach/)、[1488. 避免洪水泛滥](https://leetcode-cn.com/problems/avoid-flood-in-the-city/)



# 堆专题（上）

## 一、堆系列问题的特点

> 注：本文章系本人阅读[博主lucifer的leetcode题解](https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/)做的总结，涉及到的题目均来自[leetcode官网](https://leetcode-cn.com/)，侵删。

### 1.1 **中心**：动态求极值

堆一般用于求极值问题，但如果不是动态的就没必要使用堆，会增加时间成本。

所谓动态，简单来说就是堆内数据在动态变化，也就是堆的大小在变化，下面举例说明。

> **例一、1046.[最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)**
>
> **题目描述：**
>
> 有一堆石头，每块石头的重量都是正整数。
>
> 每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
>
> 如果 x == y，那么两块石头都会被完全粉碎；
> 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
> 最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。
>
> **思路：**
>
> 每次选择最重的两块石头进行粉碎之后，最重的石头的重量便发生了改变，将会影响到下次取最重的石头，简单来说就是最重的石头在模拟过程中是**动态变化**的。
>
> **代码：**
>
> ```java
> public int lastStoneWeight(int[] stones) {
>      int n = stones.length;
>      PriorityQueue<Integer> maxHeap = new PriorityQueue<>(n, (a, b) -> b - a);
>      for (int stone : stones) {
>          maxHeap.add(stone);
>      }   
>      while (maxHeap.size() >= 2) {
>          Integer head1 = maxHeap.poll();
>          Integer head2 = maxHeap.poll();
>          if (head1==head2) {
>              continue;
>          }
>          maxHeap.offer(head1 - head2);
>      }
>      if (maxHeap.isEmpty()) {
>          return 0;
>      }
>      return maxHeap.poll();
>  }
> ```
>
> **例二、313. [超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)**
>
> **题目描述：**
>
> 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。
>
> 给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。
>
> 题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。
>
> **思路：**
>
> 对于丑数的定义，有以下结论：
>
> - 1是最小的丑数
> - 对于任意一个丑数x，其与任意给定的质因数primes[i]相乘，结果仍为丑数。
>
> 解题步骤：
>
> 1. 起始先将最小丑数 1 放入队列
> 2. 每次从队列取出最小值 x，然后将 x 所对应的丑数 x * primes[i]进行入队。
> 3. 对步骤 2 循环多次，第 n 次出队的值即是答案。
>
> **代码：**
>
> ```java
> public int nthSuperUglyNumber(int n, int[] primes){
>         PriorityQueue<Integer> queue=new PriorityQueue<>();
>         queue.add(1);
>         while(n-- > 0) {
>             int x = queue.poll();
>             if (n == 0) return x;
>             for(int k : primes) {
>                 if (k <= Integer.MAX_VALUE / x) queue.add(k * x);
>                 if (x % k == 0) break;
>             }
>         }
>         return -1;
>     }
> ```
>

### 1.2 **实现**：二叉堆

以小顶堆为例，实现堆的功能，关键是始终维持堆的性质不变，也就是父节点的权值不大于子节点的权值。

为了达到这个目的，我们需要在出堆和入堆的时候，使用上浮和下沉操作，并恰当地完成元素交换。具体来说就是上浮过程和比它大的父节点进行交换，下沉过程和两个子节点中较小的进行交换，当然前提是它有两个子节点且子结点比它小。

> **关键代码：**
>
> ```java
> /**
>  * 前置条件：起点为1
>  * 核心方法:
>  * shiftDown: 交换下沉
>  * shiftUp: 交换上浮
>  * build: 构建堆
>  **/
> 
> public void shiftDown(int i) {
>         int temp = queue[i];
>         while ((i << 1) <= size) {
>             int child = i << 1;
>             if (child != size && queue[child+1] < queue[child]) {
>                 child++;
>             }
>             if (temp > queue[child]) {
>                 queue[i] = queue[child];
>                 i = child;
>             } else {
>                 break;
>             }
>         }
>         queue[i] = temp;
>     }
> 
> public void shiftUp(int i) {
>         int temp = queue[i];
>         while ((i >> 1)>0) {
>             if (temp < queue[i >> 1]) {
>                 queue[i] = queue[i >> 1];
>                 i >>= 1;
>             } else {
>                 break;
>             }
>         }
>         queue[i] = temp;
>     }
> 
> public void buildHeap() {
>         for (int i = size >> 1; i > 0; i--) {
>             shiftDown(i);
>         }
>     }
> ```

### 1.3 解题技巧

#### 技巧一：固定堆

这个技巧指的是固定堆的大小k不变，代码上可以通过每pop出去一个就push进来一个来实现。

> **例一：** [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
>
> **思路**：建立小顶堆，并维持堆的大小为k。处理完最后一个元素，堆顶的数就是所求。
>
> **代码**：
>
> ```java
> public int findKthLargest(int[] nums, int k) {
>      PriorityQueue<Integer> pq = new PriorityQueue<>();
>      for (int num : nums){
>          pq.offer(num);
>          if (pq.size() > k){
>              pq.poll();
>          }
>      }
>      return pq.poll();
>  }
> ```
>
> **例二：**[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)
>
> **思路：**
>
> 建立一个**小顶堆**，然后遍历「出现次数数组」
>
> 如果堆的元素个数小于 k，就可以直接插入堆中。
> 如果堆的元素个数等于 k，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 k 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。（[题解来源](https://leetcode-cn.com/problems/top-k-frequent-elements/solution/qian-k-ge-gao-pin-yuan-su-by-leetcode-solution/)）
>
> **代码：**
>
> ```java
> public int[] topKFrequent(int[] nums, int k) {
>         Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();
>         for (int num : nums) {
>             occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);
>         }
>         PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {
>             @Override
>             public int compare(int[] o1, int[] o2) {
>                 return o1[1] - o2[1];
>             }
>         });
>         for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {
>             Integer num = entry.getKey();
>             Integer count = entry.getValue();
>             if (queue.size() == k) {
>                 if (queue.peek()[1] < count) {
>                     queue.poll();
>                     queue.offer(new int[]{num, count});
>                 }
>             } else {
>                 queue.offer(new int[]{num, count});
>             }
>         }
>         int[] ret = new int[k];
>         for (int i = 0; i < k; i++) {
>             ret[i] = queue.poll()[0];
>         }
>         return ret;
>     }
> ```
>
> **其他相关题目：**[295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)、[857. 雇佣 K 名工人的最低成本](https://leetcode-cn.com/problems/minimum-cost-to-hire-k-workers/)

#### 技巧二：多路归并

这个技巧可以运用在前面的超级丑数问题上。（[题解](https://leetcode-cn.com/problems/super-ugly-number/solution/gong-shui-san-xie-yi-ti-shuang-jie-you-x-jyow/)）

多路体现在：有多条候选路线。代码上，我们可使用多指针来表示。
归并体现在：结果可能是多个候选路线中最长的或者最短，也可能是第 k 个 等。因此我们需要对多条路线的结果进行比较，并根据题目描述舍弃或者选取某一个或多个路线。	

> **例子：**[1439. 有序矩阵中的第 k 个最小数组和](https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/)
>
> **思路：**这道题就是给你 m 个长度均相同的一维数组，让我们从这 m 个数组中分别选出一个数，即一共选取 m 个数，求这 m 个数的和是所有选取可能性中和第 k 小的。
>
> 而最小的我们是容易知道的，即所有的一维数组首项和。我们又发现，根据最小的，我们可以推导出第 2 小，推导的方式就是移动其中一个指针，这就一共分裂出了 n 种情况了，其中 n 为一维数组长度，第 2 小的就在这分裂中的 n 种情况中，而筛选的方式是这 n 种情况和最小的，后面的情况也是类似。不难看出每次分裂之后极值也发生了变化，因此这是一个明显的求动态求极值的信号，使用堆是一个不错的选择。
>
> 不得不说，难度为hard的题果真不是我这个阶段能轻易overcome的。这里依旧上[题解](https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/solution/java-qing-xi-liang-chong-jie-fa-1bao-li-vtu4n/)：
>
> ​		一个类似于层次遍历的思路，每次利用最小堆 弹出上次的最小值以及坐标，然后依次将坐标往后挪动1位，再放入最小堆。
>
> **代码：**
>
> ```java
> class Solution {
>     class Info implements Comparable<Info>{
> 		int currentSum;
> 		List<Integer> pointers;
> 		Info(int currentSum,List<Integer> pointers){
> 			this.currentSum = currentSum;
> 			this.pointers = pointers;
> 		}
> 		@Override
> 		public String toString() {
> 			return this.currentSum+","+this.pointers;
> 		}
> 		@Override
> 		public int compareTo(Info other) {//从小到大排序
> 			return this.currentSum-other.currentSum;
> 		}
> 		
> 	}
>   public int kthSmallest(int[][] mat, int k) {
>     	
>     	int m = mat.length,n=mat[0].length;
>     	PriorityQueue<Info> queue= new PriorityQueue<Info>();
>     	Set<List<Integer>> seen = new HashSet<>();
>     	int currentSum = 0;
>     	List<Integer> pointers = new ArrayList<>();// 用int[]， contains识别不出来
>     	for(int i=0;i<m;++i) {
>     		currentSum+=mat[i][0];
>     		pointers.add(0);
>     		
>     	}
>     	queue.offer(new Info(currentSum,pointers));
>     	seen.add(pointers);
>     	for(int i=0;i<k;++i) {
>     		Info info = queue.poll();
>     		currentSum = info.currentSum;
>     		pointers = info.pointers;
>     		//每个指针轮流向后移动1个
>     		for(int row=0;row<m;++row) {
>     			List<Integer> newpointers = new ArrayList<>(pointers);
>     			int newsum = currentSum;
>     			int col = pointers.get(row);
>     			if(col<n-1) {
>     				newpointers.set(row, col+1);
>     				if(!seen.contains(newpointers)) {
>     					newsum  += -mat[row][col]+mat[row][col+1];
>     					queue.offer(new Info(newsum,newpointers));
>     					seen.add(newpointers);
>     				}
>     			}
>     		}
>     		
>     	}
>     	
>     	return currentSum;
>     	
>     }
> }
> 
> 作者：SamanthaChen
> 链接：https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/solution/java-qing-xi-liang-chong-jie-fa-1bao-li-vtu4n/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
> ```
>
> **其他相关题目：**（均为hard)[719. 找出第 k 小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)、[632. 最小区间](https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/)、[1675. 数组的最小偏移量](https://leetcode-cn.com/problems/minimize-deviation-in-array/)

#### 技巧三：事后小诸葛

思路： 

例题：[1642. 可以到达的最远建筑](https://leetcode-cn.com/problems/furthest-building-you-can-reach/)、[1488. 避免洪水泛滥](https://leetcode-cn.com/problems/avoid-flood-in-the-city/)

>>>>>>> f09dc4b2a2cedc9a919d0bb0e7ad6f40e183c11c
>>>>>>> fe7b4a02dd91cfd2b3d33e6d6aa9277432854f76
题解：https://blog.csdn.net/qq_24210431/article/details/106918457